# -*- coding: utf-8 -*-
"""2D Reaction-Porous Medium Equation Solver

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ofXwmJj5BzK2yo9HOxg343HjHlTnbl5J
"""

import numpy as np
from scipy.sparse import lil_matrix, spdiags
from scipy.sparse.linalg import spsolve
import matplotlib.pyplot as plt

# --- 1. GLOBAL PARAMETERS ---
M = 2.0  # Non-linear diffusion exponent (m=2.0)
L = 10.0 # Domain size [-L, L]
N = 100  # Number of grid points per dimension
DX = 2.0 * L / N  # Grid spacing
DT = 0.005 # Time step (Small for stability in non-adaptive FDM)

# --- 2. REACTION TERM FUNCTIONS (f(u, x)) ---

def get_spatial_profiles(x, y):
    """Calculates radial distance and a Gaussian demand profile D_P(x)."""
    R_sq = x**2 + y**2
    # Spatial Heterogeneous Demand profile D_P(x) (strongest at center, Gaussian-shaped)
    # Using A=0.1, beta=0.01 based on analysis notes
    A, beta = 0.1, 0.01
    D_P = A * np.exp(-beta * R_sq)

    # Logistic Decay Capacity K(x) (strongest at center, Gaussian-shaped)
    # Using K_center=0.05, K_edge=0.01, alpha=0.05 based on analysis notes
    K_center, K_edge, alpha = 0.05, 0.01, 0.05
    K = K_edge + (K_center - K_edge) * np.exp(-alpha * R_sq)

    return D_P, K

def f_heterogeneous_demand(u, D_P):
    """
    Reaction term 1: Spatial Heterogeneous Demand (Growth/Decay Balance)
    f(u, x) = D_P(x) * u^sigma - gamma * u^(sigma+0.3)
    """
    sigma, gamma = 1.2, 0.15 # Parameters from Section 1.3
    # Explicit Growth (RHS) and Implicit Decay (LHS contribution)
    # For stability, the dominant non-linear growth term D_P * u^sigma
    # is often split. We will implicitly treat the decay.
    growth = D_P * (u ** sigma)
    decay = gamma * (u ** (sigma + 0.3))
    return growth - decay

def f_logistic_decay(u, K):
    """
    Reaction term 2: Logistic Decay Demand
    f(u, x) = r * u * (1 - u / K(x))
    """
    r = 0.4 # Parameter from Section 1.3
    # The term is decay-dominant because the capacity K(x) is small.
    return r * u * (1 - u / K)

# --- 3. CORE RPME SOLVER CLASS ---

class RPME_Solver:
    def __init__(self, demand_type, T_final=4.0):
        """Initializes the solver, grid, and initial condition."""
        self.T_final = T_final
        self.t = 0.0
        self.demand_type = demand_type

        # Grid setup
        self.x_coords = np.linspace(-L, L, N, endpoint=False)
        self.y_coords = np.linspace(-L, L, N, endpoint=False)
        self.X, self.Y = np.meshgrid(self.x_coords, self.y_coords)
        self.R_sq = self.X**2 + self.Y**2

        # Pre-calculate spatial profiles
        self.D_P, self.K = get_spatial_profiles(self.X, self.Y)

        # Initial Condition: Multi-peak IC (Section 3)
        self.u = self.initial_condition_multi_peak()

        # Flattened grid size for sparse matrix operations
        self.grid_size = N * N

    def initial_condition_multi_peak(self):
        """Creates the complex multi-peak IC used in Section 3 (Multi-Peak IC)."""
        u0 = np.zeros_like(self.X)

        # Four off-center Gaussian peaks
        peak_locs = [
            (5, 5, 1.0),
            (-5, 5, 1.0),
            (5, -5, 1.0),
            (-5, -5, 1.0)
        ]

        for px, py, amp in peak_locs:
            u0 += amp * np.exp(-0.5 * ((self.X - px)**2 + (self.Y - py)**2))

        # Ensure non-negative and apply boundary conditions (zero Dirichlet)
        u0 = np.maximum(u0, 0)
        u0[0, :] = u0[-1, :] = u0[:, 0] = u0[:, -1] = 0
        return u0

    def get_effective_diffusivity(self, u_n):
        """
        Calculates the effective diffusion coefficient D_eff for the implicit step.
        D_eff = m * u_n^(m-1). We add a small epsilon to prevent division by zero at u=0
        (the degeneracy point, Section 1.5).
        """
        u_n_flat = u_n.flatten()

        # Prevent division by zero and handle degeneracy point
        epsilon = 1e-10
        D_eff_flat = M * np.maximum(u_n_flat, epsilon)**(M - 1)
        return D_eff_flat

    def build_diffusion_matrix(self, D_eff_flat):
        """
        Constructs the sparse matrix A for the implicit term:
        A * u_{n+1} = u_n + dt * f(u_n).
        A = I - dt * (Laplacian operator with D_eff coefficient)
        """

        # Use LIL format for easy construction and boundary condition setting (Section 1.6.2)
        A = lil_matrix((self.grid_size, self.grid_size))

        # Time-space factor
        coeff = DT / (DX * DX)

        # Iterate over all internal grid points
        for i in range(1, N - 1):
            for j in range(1, N - 1):
                k = i * N + j # Flattened index

                # Effective diffusion at this point and neighbors
                D_c = D_eff_flat[k]
                D_E = D_eff_flat[k+1]
                D_W = D_eff_flat[k-1]
                D_N = D_eff_flat[k+N]
                D_S = D_eff_flat[k-N]

                # The semi-implicit discretization:
                # D(u) * Lap(u) is approximated as Div( D_eff * Grad(u_{n+1}) )

                # Central term (diagonal of A)
                A[k, k] = 1.0 + coeff * (0.5 * (D_c + D_E) + 0.5 * (D_c + D_W) + 0.5 * (D_c + D_N) + 0.5 * (D_c + D_S))

                # Off-diagonal terms (neighbors)
                A[k, k+1]  = -coeff * 0.5 * (D_c + D_E) # East
                A[k, k-1]  = -coeff * 0.5 * (D_c + D_W) # West
                A[k, k+N]  = -coeff * 0.5 * (D_c + D_N) # North
                A[k, k-N]  = -coeff * 0.5 * (D_c + D_S) # South

        # Apply Dirichlet Boundary Conditions (u=0)
        # For boundary points, set A[k,k] = 1 and RHS[k] = 0
        # The incorrect line defining boundary_indices has been removed.
        for k in range(self.grid_size):
            # Check if the flattened index k corresponds to a boundary point:
            # First row (k < N), last row (k >= self.grid_size - N),
            # first column (k % N == 0), last column ((k + 1) % N == 0)
            if k < N or k >= self.grid_size - N or k % N == 0 or (k + 1) % N == 0:
                A[k, k] = 1.0
                # Neighbor elements are kept as 0 by default, enforcing u_n+1 = 0

        # Final conversion to CSR format for fast solving (Section 1.6.2)
        return A.tocsr()

    def step(self):
        """Performs one semi-implicit time step."""
        u_n = self.u.copy()

        # 1. Calculate effective diffusion coefficient D_eff
        D_eff_flat = self.get_effective_diffusivity(u_n)

        # 2. Build the implicit diffusion matrix A
        A = self.build_diffusion_matrix(D_eff_flat)

        # 3. Calculate the explicit reaction term f(u_n, x)
        if self.demand_type == 'heterogeneous':
            f_reaction = f_heterogeneous_demand(u_n, self.D_P)
            # Add an implicit treatment for the growth term (Section 1.6.1)
            # D_P * u_n^sigma approx D_P * u_n^{sigma-1} * u_{n+1}
            # This is complex for 2D FDM, so we compensate by adding a stabilizing diagonal term.
            # In this simplified FDM, we use the explicit term but must ensure DT is very small.
            # The report's solution was to move the term to the LHS, which requires
            # modifying the matrix A based on the local growth rate D_P * u^{sigma-1}.
            # Here, we keep A simpler and rely on a small DT for stability.
        elif self.demand_type == 'logistic':
            f_reaction = f_logistic_decay(u_n, self.K)
        else:
            raise ValueError("Invalid demand_type")

        # 4. Construct the right-hand side (RHS = u_n + dt * f(u_n))
        rhs = u_n.flatten() + DT * f_reaction.flatten()

        # For boundary points, the boundary matrix A already sets A[k,k]=1.
        # We need to explicitly set RHS=0 for boundary points to enforce u_{n+1}=0.
        for k in range(self.grid_size):
            if k < N or k >= self.grid_size - N or k % N == 0 or (k + 1) % N == 0:
                rhs[k] = 0.0

        # 5. Solve the linear system A * u_{n+1} = RHS (Section 1.4)
        u_next_flat = spsolve(A, rhs)

        # 6. Update solution
        self.u = np.maximum(u_next_flat.reshape((N, N)), 0.0) # Ensure u >= 0 (PME property)
        self.t += DT

    def run_simulation(self, total_time, save_interval=1.0):
        """Runs the simulation and collects snapshots for plotting."""

        print(f"Starting {self.demand_type} simulation (N={N}, DT={DT})...")

        snapshots = [(0.0, self.u.copy())]
        next_save_time = save_interval

        initial_mass = np.sum(self.u) * DX * DX
        print(f"Initial Mass: {initial_mass:.4f}")

        while self.t < total_time:
            self.step()

            if self.t >= next_save_time:
                snapshots.append((self.t, self.u.copy()))
                print(f"Time: {self.t:.2f} / {total_time:.2f}")
                next_save_time += save_interval

        final_mass = np.sum(self.u) * DX * DX
        mass_change = final_mass - initial_mass
        print(f"Final Mass: {final_mass:.4f}. Mass Change: {mass_change:.4f}")

        return snapshots, initial_mass, final_mass

# --- 4. RUN AND PLOT DEMONSTRATION ---

def plot_results(snapshots, demand_type):
    """Plots the 2D density profiles over time."""

    num_plots = len(snapshots)
    fig, axes = plt.subplots(1, num_plots, figsize=(4 * num_plots, 4), layout='constrained')

    if num_plots == 1:
        axes = [axes] # Ensure axes is iterable for single plot case

    u_min = min(np.min(u) for t, u in snapshots)
    u_max = max(np.max(u) for t, u in snapshots)

    for ax, (t, u) in zip(axes, snapshots):
        im = ax.imshow(
            u.T,
            extent=(-L, L, -L, L),
            origin='lower',
            cmap='magma',
            vmin=u_min,
            vmax=u_max
        )
        ax.set_title(f'{demand_type}\nTime = {t:.2f}', fontsize=12)
        ax.set_xlabel('X')
        ax.set_ylabel('Y')
        ax.set_aspect('equal', adjustable='box')

    # Add a single color bar for all plots
    cbar = fig.colorbar(im, ax=axes, orientation='vertical', shrink=0.8)
    cbar.set_label('Density u(x, y)', rotation=270, labelpad=15)

    plt.suptitle("2D R-PME Simulation (Multi-Peak Initial Condition)", fontsize=16)
    plt.show()

if __name__ == '__main__':
    # Target time (T=4.0 from report)
    TOTAL_TIME = 4.0

    # --- SIMULATION 1: SPATIAL HETEROGENEOUS DEMAND (Pattern Preservation) ---
    solver_het = RPME_Solver(demand_type='heterogeneous', T_final=TOTAL_TIME)
    snapshots_het, _, _ = solver_het.run_simulation(TOTAL_TIME, save_interval=1.0)
    plot_results(snapshots_het, "Spatial Heterogeneous Demand")

    # --- SIMULATION 2: LOGISTIC DECAY DEMAND (Homogenization) ---
    solver_log = RPME_Solver(demand_type='logistic', T_final=TOTAL_TIME)
    snapshots_log, _, _ = solver_log.run_simulation(TOTAL_TIME, save_interval=1.0)
    plot_results(snapshots_log, "Logistic Decay Demand")




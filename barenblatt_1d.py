# -*- coding: utf-8 -*-
"""barenblatt_1d.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zh_YodnS7dpWZw4m5Efjitz2ZOgc04oX
"""

# -*- coding: utf-8 -*-
"""
examples/barenblatt_1d.py
1-D Barenblatt test – fully aligned with Sec. 7.3.1 (m = 2)
Works in:
    • a normal .py file (GitHub clone)
    • Google Colab / Jupyter notebooks
"""

import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path
import os
import sys

# ----------------------------------------------------------------------
# 1. Parameters – Sec. 7.3.1 (m = 2)
# ----------------------------------------------------------------------
m       = 2.0
alpha   = 1.0 / (m + 1.0)                     # 1/3
beta    = 1.0 / (m + 1.0)                     # 1/3   (1-D)
kappa   = 1.0 / (2.0 * (m + 1.0))            # 1/6
C       = (np.pi)**(1.0/3.0) * (3.0/8.0)**(2.0/3.0)   # total mass = 1.0
t0      = 0.1
t_final = 1.0
L       = 15.0
Nx      = 1024
dx      = 2.0 * L / Nx
x       = np.linspace(-L, L, Nx + 1)
xc      = x[:-1] + dx / 2.0

# ----------------------------------------------------------------------
# 2. Exact Barenblatt
# ----------------------------------------------------------------------
def barenblatt_exact(x, t):
    xi = np.abs(x) / t**beta
    inside = C - kappa * xi**2
    u = np.zeros_like(x)
    pos = inside > 0
    u[pos] = t**(-alpha) * inside[pos]**(1.0/(m-1.0))
    return u

def support_radius(t):
    return np.sqrt(C / kappa) * t**beta

# ----------------------------------------------------------------------
# 3. Numerical scheme (IMEX BDF1)
# ----------------------------------------------------------------------
def pme_rhs(t, u):
    u_c = u.copy()
    u_left  = np.concatenate(([u_c[0]], u_c[:-1]))
    u_right = np.concatenate((u_c[1:], [u_c[-1]]))
    u_int   = 0.5 * (u_left + u_right)
    D_int   = u_int**m
    grad_u  = (u_right - u_left) / dx
    flux    = D_int * grad_u
    flux_left  = np.concatenate(([flux[0]], flux[:-1]))
    flux_right = np.concatenate((flux[1:], [flux[-1]]))
    return (flux_right - flux_left) / dx

def step_bdf1(t, u, dt):
    rhs_expl = pme_rhs(t, u)
    u_new = u.copy()
    for _ in range(20):
        rhs_impl = pme_rhs(t + dt, u_new)
        u_new = u + dt * (0.5 * rhs_expl + 0.5 * rhs_impl)
    return u_new

def cfl_dt(u, dx, safety=0.4):
    D_max = np.max(u**m) if np.max(u) > 0 else 1.0
    return safety * dx**2 / (2.0 * D_max)

# ----------------------------------------------------------------------
# 4. Initial condition
# ----------------------------------------------------------------------
u = barenblatt_exact(xc, t0)
mass0 = np.sum(u) * dx
print(f"Initial mass = {mass0:.6f}")

# ----------------------------------------------------------------------
# 5. Time integration
# ----------------------------------------------------------------------
t = t0
history = []

while t < t_final:
    dt = min(cfl_dt(u, dx), t_final - t)
    u = step_bdf1(t, u, dt)
    t += dt

    mass = np.sum(u) * dx
    active = u > 1e-12
    left  = xc[active][ 0] if np.any(active) else -L
    right = xc[active][-1] if np.any(active) else  L
    history.append((t, left, right, mass))

    if int(t * 1000) % 10 == 0:
        print(f"t={t:.3f}  dt={dt:.2e}  mass={mass:.6f}  support=[{left:.2f},{right:.2f}]")

# ----------------------------------------------------------------------
# 6. Post-processing
# ----------------------------------------------------------------------
history = np.array(history)
t_hist, sL, sR, mass_hist = history.T
u_exact = barenblatt_exact(xc, t_final)
L2_err = np.sqrt(np.sum((u - u_exact)**2) * dx)

# ----------------------------------------------------------------------
# 7. Figure directory – **universal**
# ----------------------------------------------------------------------
# In a .py file:  repo_root/examples/../figures
# In Colab / notebook: current working directory / figures
if '__file__' in globals():
    FIG_DIR = Path(__file__).resolve().parent.parent / "figures"
else:
    FIG_DIR = Path(os.getcwd()) / "figures"
FIG_DIR.mkdir(parents=True, exist_ok=True)

# ----------------------------------------------------------------------
# 8. Plot 1 – solution comparison
# ----------------------------------------------------------------------
plt.figure(figsize=(6,4))
plt.plot(xc, u, 'b-', lw=1.5, label='Numerical')
plt.plot(xc, u_exact, 'r--', lw=1.5, label='Exact Barenblatt')
plt.xlabel(r'$x$')
plt.ylabel(r'$u(x,1)$')
plt.title(f'Barenblatt at $t=1$ (Nx={Nx})')
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig(FIG_DIR / "barenblatt_comparison.png", dpi=300)
plt.close()
print("saved • barenblatt_comparison.png")

# ----------------------------------------------------------------------
# 9. Plot 2 – free-boundary evolution
# ----------------------------------------------------------------------
plt.figure(figsize=(6,4))
plt.plot(t_hist, sL, 'C0-', label='Left boundary')
plt.plot(t_hist, sR, 'C1-', label='Right boundary')
t_th = np.linspace(t0, t_final, 200)
plt.plot(t_th, -support_radius(t_th), 'k--', lw=1, label='Exact')
plt.plot(t_th,  support_radius(t_th), 'k--', lw=1)
plt.xlabel('time $t$')
plt.ylabel('support')
plt.title('Free-boundary evolution')
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig(FIG_DIR / "free_boundary_evolution.png", dpi=300)
plt.close()
print("saved • free_boundary_evolution.png")

# ----------------------------------------------------------------------
# 10. Validation summary
# ----------------------------------------------------------------------
mass_err = abs(mass_hist[-1] - mass0) / mass0
print("\n=== VALIDATION SUMMARY ===")
print(f"Final mass error : {mass_err:.2e}")
print(f"L² error         : {L2_err:.2e}")
print(f"Support at t=1   : [{sL[-1]: .2f}, {sR[-1]: .2f}]")
print(f"Exact radius     : ±{support_radius(t_final):.2f}")
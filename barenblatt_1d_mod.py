# -*- coding: utf-8 -*-
"""barenblatt_1d_mod.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1me6OfgJ2a2zzaA3CaRWUF8zCoRCydvt0
"""

# -*- coding: utf-8 -*-
"""
examples/barenblatt_1d_mod.py
1-D Barenblatt test – Section 7.3.1
Embedded config + optional adaptive mesh
Works in GitHub clone, Colab, Jupyter
"""

import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path
import os

# ----------------------------------------------------------------------
# 0. CONFIGURATION (embedded – no config.py needed)
# ----------------------------------------------------------------------
USE_ADAPTIVE_MESH      = False   # ← SET True FOR ADAPTIVE MESH
REFINEMENT_STRATEGY    = 'hardy_gradient'
REFINE_THRESHOLD       = 0.02
COARSEN_THRESHOLD      = 0.005
MAX_REFINEMENT_LEVEL   = 4
MIN_DX                 = 0.01

# ----------------------------------------------------------------------
# 1. Parameters – Sec. 7.3.1 (m = 2)
# ----------------------------------------------------------------------
m       = 2.0
alpha   = 1.0 / (m + 1.0)                     # 1/3
beta    = 1.0 / (m + 1.0)                     # 1/3 (1-D)
kappa   = 1.0 / (2.0 * (m + 1.0))            # 1/6
C       = (np.pi)**(1.0/3.0) * (3.0/8.0)**(2.0/3.0)   # mass = 1.0
t0      = 0.1
t_final = 1.0
L       = 15.0

# ----------------------------------------------------------------------
# 2. Adaptive Mesh 1D (lightweight)
# ----------------------------------------------------------------------
class AdaptiveMesh1D:
    def __init__(self, xmin, xmax, initial_cells=64):
        self.xmin = xmin
        self.xmax = xmax
        self.level = np.zeros(initial_cells, dtype=int)
        self.rebuild()

    def rebuild(self):
        N = len(self.level)
        self.interfaces = np.linspace(self.xmin, self.xmax, N + 1)
        self.centers = self.interfaces[:-1] + np.diff(self.interfaces)/2
        self.dx = np.diff(self.interfaces)

    def refine(self, indicator):
        to_refine = (indicator > REFINE_THRESHOLD) & (self.level < MAX_REFINEMENT_LEVEL)
        if not np.any(to_refine): return False
        new_int = [self.xmin]
        for i in range(len(self.level)):
            if to_refine[i]:
                self.level[i] += 1
                mid = (self.interfaces[i] + self.interfaces[i+1]) / 2
                new_int.extend([mid, self.interfaces[i+1]])
            else:
                new_int.append(self.interfaces[i+1])
        self.interfaces = np.array(new_int)
        self.rebuild()
        return True

    def coarsen(self, indicator):
        to_coarsen = (indicator < COARSEN_THRESHOLD) & (self.level > 0)
        if not np.any(to_coarsen): return False
        keep = np.ones(len(self.level), dtype=bool)
        i = 0
        while i < len(self.level) - 1:
            if to_coarsen[i] and to_coarsen[i+1] and self.level[i] == self.level[i+1]:
                keep[i] = keep[i+1] = False
                self.level[i] -= 1
                i += 2
            else:
                i += 1
        self.level = self.level[keep]
        self.rebuild()
        return True

# ----------------------------------------------------------------------
# 3. Exact Barenblatt
# ----------------------------------------------------------------------
def barenblatt_exact(x, t):
    xi = np.abs(x) / t**beta
    inside = C - kappa * xi**2
    u = np.zeros_like(x)
    pos = inside > 0
    u[pos] = t**(-alpha) * inside[pos]**(1.0/(m-1.0))
    return u

def support_radius(t):
    return np.sqrt(C / kappa) * t**beta

# ----------------------------------------------------------------------
# 4. Numerical scheme
# ----------------------------------------------------------------------
def pme_rhs(u, dx, m):
    u_left  = np.concatenate(([u[0]], u[:-1]))
    u_right = np.concatenate((u[1:], [u[-1]]))
    u_int   = 0.5 * (u_left + u_right)
    D_int   = u_int**m
    grad_u  = (u_right - u_left) / dx
    flux    = D_int * grad_u
    flux_left  = np.concatenate(([flux[0]], flux[:-1]))
    flux_right = np.concatenate((flux[1:], [flux[-1]]))
    return (flux_right - flux_left) / dx

def step_bdf1(u, dt, dx, m):
    rhs_expl = pme_rhs(u, dx, m)
    u_new = u.copy()
    for _ in range(20):
        rhs_impl = pme_rhs(u_new, dx, m)
        u_new = u + dt * (0.5 * rhs_expl + 0.5 * rhs_impl)
    return u_new

def cfl_dt(u, dx, safety=0.4):
    D_max = np.max(u**m) if np.max(u) > 0 else 1.0
    return safety * dx**2 / (2.0 * D_max)

# ----------------------------------------------------------------------
# 5. Mesh setup
# ----------------------------------------------------------------------
if USE_ADAPTIVE_MESH:
    mesh = AdaptiveMesh1D(xmin=-L, xmax=L, initial_cells=64)
    xc = mesh.centers.copy()
    dx = mesh.dx.copy()
else:
    Nx = 1024
    dx_val = 2*L / Nx
    xc = np.linspace(-L + dx_val/2, L - dx_val/2, Nx)
    dx = np.full(Nx, dx_val)

u = barenblatt_exact(xc, t0)
mass0 = np.sum(u * dx)
print(f"Initial mass = {mass0:.6f} | DOFs = {len(u)}")

# ----------------------------------------------------------------------
# 6. Time integration + refinement
# ----------------------------------------------------------------------
t = t0
history = []
refine_steps = 0

while t < t_final:
    dt = min(cfl_dt(u, np.min(dx)), t_final - t)
    u = step_bdf1(u, dt, dx, m)
    t += dt

    if USE_ADAPTIVE_MESH and int(t * 100) % 10 == 0:
        grad = np.abs(np.gradient(u, xc))
        indicator = u**m * grad
        refined = mesh.refine(indicator)
        coarsened = mesh.coarsen(indicator)
        if refined or coarsened:
            refine_steps += 1
            u_old = u.copy()
            xc_old = xc.copy()
            xc = mesh.centers
            dx = mesh.dx
            u = np.interp(xc, xc_old, u_old, left=0.0, right=0.0)

    mass = np.sum(u * dx)
    active = u > 1e-12
    left  = xc[active][ 0] if np.any(active) else -L
    right = xc[active][-1] if np.any(active) else  L
    history.append((t, left, right, mass, len(u)))

    if int(t * 1000) % 10 == 0:
        print(f"t={t:.3f}  dt={dt:.2e}  mass={mass:.6f}  DOFs={len(u)}  support=[{left:.2f},{right:.2f}]")

# ----------------------------------------------------------------------
# 7. Post-processing
# ----------------------------------------------------------------------
history = np.array(history)
t_hist, sL, sR, mass_hist, dofs_hist = history.T
u_exact = barenblatt_exact(xc, t_final)
L2_err = np.sqrt(np.sum((u - u_exact)**2 * dx))

# ----------------------------------------------------------------------
# 8. Figure directory (universal)
# ----------------------------------------------------------------------
if '__file__' in globals():
    FIG_DIR = Path(__file__).resolve().parent.parent / "figures"
else:
    FIG_DIR = Path(os.getcwd()) / "figures"
FIG_DIR.mkdir(parents=True, exist_ok=True)

# ----------------------------------------------------------------------
# 9. Plot 1 – solution comparison
# ----------------------------------------------------------------------
plt.figure(figsize=(6,4))
plt.plot(xc, u, 'b-', lw=1.5, label='Numerical')
plt.plot(xc, u_exact, 'r--', lw=1.5, label='Exact Barenblatt')
plt.xlabel(r'$x$')
plt.ylabel(r'$u(x,1)$')
plt.title(f'Barenblatt at $t=1$ (DOFs={len(u)})')
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig(FIG_DIR / "barenblatt_1d_mod_comparison.png", dpi=300)
plt.close()
print("saved • barenblatt_1d_mod_comparison.png")

# ----------------------------------------------------------------------
# 10. Plot 2 – free-boundary + DOFs
# ----------------------------------------------------------------------
fig, ax1 = plt.subplots(figsize=(6,4))
ax1.plot(t_hist, sL, 'C0-', label='Left boundary')
ax1.plot(t_hist, sR, 'C1-', label='Right boundary')
t_th = np.linspace(t0, t_final, 200)
ax1.plot(t_th, -support_radius(t_th), 'k--', lw=1, label='Exact')
ax1.plot(t_th,  support_radius(t_th), 'k--', lw=1)
ax1.set_xlabel('time $t$')
ax1.set_ylabel('support')
ax1.legend(loc='upper left')
ax1.grid(True, alpha=0.3)

ax2 = ax1.twinx()
ax2.plot(t_hist, dofs_hist, 'g:', alpha=0.6, label='DOFs')
ax2.set_ylabel('DOFs', color='g')
ax2.legend(loc='upper right')

plt.title('Free-boundary evolution + mesh size')
plt.tight_layout()
plt.savefig(FIG_DIR / "barenblatt_1d_mod_evolution.png", dpi=300)
plt.close()
print("saved • barenblatt_1d_mod_evolution.png")

# ----------------------------------------------------------------------
# 11. Validation summary
# ----------------------------------------------------------------------
mass_err = abs(mass_hist[-1] - mass0) / mass0
print("\n=== VALIDATION SUMMARY ===")
print(f"Final mass error : {mass_err:.2e}")
print(f"L² error         : {L2_err:.2e}")
print(f"Support at t=1   : [{sL[-1]: .2f}, {sR[-1]: .2f}]")
print(f"Exact radius     : ±{support_radius(t_final):.2f}")
print(f"Final DOFs       : {int(dofs_hist[-1])}")